<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Easy Gesture Portfolio</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: #fff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #webcam-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 240px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 10;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #webcam-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas-3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(20, 20, 40, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: all;
        }
        
        #welcome-panel {
            top: 50%;
            left: 40px;
            transform: translateY(-50%);
            width: 450px;
            max-width: 40vw;
        }
        
        #gesture-help {
            bottom: 30px;
            left: 30px;
            width: 350px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #a6c1ee;
        }
        
        h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #6a93cb;
        }
        
        p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #ccd6f6;
        }
        
        .highlight {
            color: #6a93cb;
            font-weight: bold;
        }
        
        .gesture-icon {
            display: inline-block;
            width: 50px;
            height: 50px;
            background: rgba(106, 17, 203, 0.2);
            border-radius: 50%;
            text-align: center;
            line-height: 50px;
            margin-right: 15px;
            font-weight: bold;
            border: 2px solid #6a11cb;
            font-size: 1.5rem;
        }
        
        .gesture-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .gesture-item.active {
            background: rgba(106, 17, 203, 0.2);
        }
        
        .gesture-text {
            color: #ccd6f6;
            font-size: 1.1rem;
        }
        
        #gesture-status {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(20, 20, 40, 0.85);
            padding: 12px 20px;
            border-radius: 30px;
            font-weight: bold;
            z-index: 3;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-active {
            background-color: #00ff88;
            box-shadow: 0 0 10px #00ff88;
            animation: pulse 2s infinite;
        }
        
        .status-inactive {
            background-color: #ff4444;
        }
        
        #navigation {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 15px;
            z-index: 3;
        }
        
        .nav-btn {
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            pointer-events: all;
        }
        
        .nav-btn:hover {
            transform: scale(1.1);
        }
        
        #instruction-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 25, 0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            text-align: center;
        }
        
        #start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.2rem;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.3s;
        }
        
        #start-btn:hover {
            transform: scale(1.05);
        }
        
        .gesture-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            z-index: 5;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }
        
        .gesture-feedback.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        #hand-preview {
            position: absolute;
            top: 30px;
            right: 360px;
            width: 150px;
            height: 150px;
            background: rgba(20, 20, 40, 0.7);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            z-index: 5;
        }
        
        #confidence-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        #confidence-fill {
            height: 100%;
            background: linear-gradient(to right, #00ff88, #00cc66);
            width: 0%;
            transition: width 0.3s;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        @media (max-width: 1200px) {
            #welcome-panel {
                width: 90%;
                left: 50%;
                transform: translateX(-50%) translateY(-50%);
                max-width: unset;
            }
            
            #hand-preview {
                right: 300px;
            }
        }
        
        @media (max-width: 768px) {
            #webcam-container {
                width: 200px;
                height: 150px;
                top: 10px;
                right: 10px;
            }
            
            #hand-preview {
                display: none;
            }
            
            #welcome-panel, #gesture-help {
                padding: 20px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Instruction Modal -->
        <div id="instruction-modal">
            <h1>Easy Gesture Portfolio</h1>
            <p>Control this portfolio with simple, reliable hand gestures.</p>
            <div style="margin: 30px 0; max-width: 600px;">
                <p><strong>Make sure you have good lighting and your hand is visible in the camera.</strong></p>
                <p>This works with just 3 easy gestures:</p>
                <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; margin-top: 20px;">
                    <div style="min-width: 200px;">
                        <div class="gesture-item">
                            <div class="gesture-icon">üëÜ</div>
                            <div class="gesture-text"><strong>Point</strong> - Select items</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">‚úã</div>
                            <div class="gesture-text"><strong>Open Hand</strong> - Move around</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">‚úåÔ∏è</div>
                            <div class="gesture-text"><strong>Peace Sign</strong> - Change section</div>
                        </div>
                    </div>
                </div>
                <p style="margin-top: 20px; color: #a6c1ee;">Your camera data is processed locally and never leaves your device.</p>
            </div>
            <button id="start-btn">Start Gesture Control</button>
        </div>
        
        <!-- Webcam Feed -->
        <div id="webcam-container">
            <video id="webcam-video" autoplay playsinline></video>
        </div>
        
        <!-- Hand Visualization -->
        <div id="hand-preview">
            <canvas id="hand-canvas" width="150" height="150"></canvas>
            <div id="confidence-bar">
                <div id="confidence-fill"></div>
            </div>
        </div>
        
        <!-- 3D Canvas -->
        <canvas id="canvas-3d"></canvas>
        
        <!-- Gesture Feedback -->
        <div class="gesture-feedback" id="gesture-feedback">üëÜ</div>
        
        <!-- UI Overlay -->
        <div id="ui-overlay">
            <!-- Gesture Status -->
            <div id="gesture-status">
                <span class="status-dot status-inactive" id="status-dot"></span>
                <span id="status-text">Click Start to begin</span>
            </div>
            
            <!-- Welcome Panel -->
            <div class="ui-panel" id="welcome-panel">
                <h1>Alex Morgan</h1>
                <h2 id="section-title">Interactive Developer</h2>
                <p>Welcome to my gesture-controlled portfolio! I create immersive web experiences with cutting-edge technologies.</p>
                <p><strong>Current gesture:</strong> <span class="highlight" id="current-gesture">None</span></p>
                <p><strong>Section:</strong> <span class="highlight" id="current-section">1 of 5</span></p>
                <p id="gesture-instruction">Show your hand to the camera to begin controlling the portfolio.</p>
            </div>
            
            <!-- Gesture Help -->
            <div class="ui-panel" id="gesture-help">
                <h3>Easy Gesture Controls</h3>
                <div class="gesture-item" id="gesture-point-ui">
                    <div class="gesture-icon">üëÜ</div>
                    <div class="gesture-text"><strong>Point</strong> - Select items</div>
                </div>
                <div class="gesture-item" id="gesture-open-ui">
                    <div class="gesture-icon">‚úã</div>
                    <div class="gesture-text"><strong>Open Hand</strong> - Move around</div>
                </div>
                <div class="gesture-item" id="gesture-peace-ui">
                    <div class="gesture-icon">‚úåÔ∏è</div>
                    <div class="gesture-text"><strong>Peace Sign</strong> - Change section</div>
                </div>
            </div>
            
            <!-- Navigation Buttons -->
            <div id="navigation">
                <button class="nav-btn" id="prev-btn">‚Üê</button>
                <button class="nav-btn" id="next-btn">‚Üí</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const instructionModal = document.getElementById('instruction-modal');
        const startBtn = document.getElementById('start-btn');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const currentGestureElement = document.getElementById('current-gesture');
        const sectionTitle = document.getElementById('section-title');
        const currentSectionElement = document.getElementById('current-section');
        const gestureInstruction = document.getElementById('gesture-instruction');
        const webcamVideo = document.getElementById('webcam-video');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const gestureFeedback = document.getElementById('gesture-feedback');
        const handCanvas = document.getElementById('hand-canvas');
        const handCtx = handCanvas.getContext('2d');
        const confidenceFill = document.getElementById('confidence-fill');
        
        // Gesture UI elements
        const gesturePointUI = document.getElementById('gesture-point-ui');
        const gestureOpenUI = document.getElementById('gesture-open-ui');
        const gesturePeaceUI = document.getElementById('gesture-peace-ui');
        
        // Three.js Variables
        let scene, camera, renderer;
        let objects = [];
        let currentObjectIndex = 0;
        
        // Hand Tracking Variables
        let hands = null;
        let cameraStream = null;
        let currentGesture = 'none';
        let gestureConfidence = 0;
        let lastLandmarks = null;
        let isGestureControlActive = false;
        
        // Portfolio sections
        const portfolioSections = [
            { title: "Interactive Developer", description: "Creating immersive 3D web experiences" },
            { title: "WebGL Specialist", description: "High-performance graphics for the web" },
            { title: "UI/UX Designer", description: "Beautiful and functional user interfaces" },
            { title: "AR/VR Developer", description: "Immersive reality experiences" },
            { title: "Tech Innovator", description: "Pushing the boundaries of web technology" }
        ];
        
        // Initialize the application
        async function init() {
            // Set up Three.js
            setupThreeJS();
            
            // Create 3D objects
            createPortfolioObjects();
            
            // Set up event listeners
            setupEventListeners();
            
            // Start animation loop
            animate();
        }
        
        // Set up Three.js
        function setupThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a19);
            
            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 15);
            
            // Renderer
            const canvas = document.getElementById('canvas-3d');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }
        
        // Create 3D objects
        function createPortfolioObjects() {
            const colors = [0x6a11cb, 0x2575fc, 0x12a4d9, 0x4cc9f0, 0xf72585];
            
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.SphereGeometry(1.2, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: colors[i],
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                
                // Position in a circle
                const angle = (i / 5) * Math.PI * 2;
                const radius = 6;
                mesh.position.x = Math.cos(angle) * radius;
                mesh.position.z = Math.sin(angle) * radius;
                mesh.position.y = 0;
                
                mesh.castShadow = true;
                mesh.userData = { index: i };
                
                // Add wireframe
                const wireframe = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geometry),
                    new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 1 })
                );
                mesh.add(wireframe);
                
                scene.add(mesh);
                objects.push(mesh);
            }
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a2e,
                shininess: 10,
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Start button
            startBtn.addEventListener('click', startGestureControl);
            
            // Navigation buttons
            prevBtn.addEventListener('click', () => navigateSection(-1));
            nextBtn.addEventListener('click', () => navigateSection(1));
        }
        
        // Start gesture control
        async function startGestureControl() {
            instructionModal.style.display = 'none';
            statusText.textContent = 'Starting camera...';
            
            try {
                // Initialize MediaPipe Hands
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                // Simple configuration
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 0, // Faster processing
                    minDetectionConfidence: 0.6, // Lower threshold for easier detection
                    minTrackingConfidence: 0.6
                });
                
                hands.onResults(onHandResults);
                
                // Start webcam
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: "user"
                    }
                });
                
                webcamVideo.srcObject = cameraStream;
                
                // Start processing frames
                const camera = new Camera(webcamVideo, {
                    onFrame: async () => {
                        if (isGestureControlActive) {
                            await hands.send({ image: webcamVideo });
                        }
                    },
                    width: 640,
                    height: 480
                });
                
                camera.start();
                
                // Update UI
                statusText.textContent = 'Gesture control active';
                statusDot.className = 'status-dot status-active';
                gestureInstruction.textContent = 'Show your hand to the camera to control the portfolio.';
                isGestureControlActive = true;
                
            } catch (error) {
                console.error("Error starting gesture control:", error);
                statusText.textContent = 'Camera access denied - using buttons only';
                currentGestureElement.textContent = 'Use buttons below';
                gestureInstruction.textContent = 'Use the buttons on the right to navigate.';
            }
        }
        
        // Process hand tracking results
        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                // No hand detected
                if (currentGesture !== 'none') {
                    currentGesture = 'none';
                    updateGestureUI();
                }
                return;
            }
            
            // Get the first hand
            const landmarks = results.multiHandLandmarks[0];
            lastLandmarks = landmarks;
            
            // Draw hand visualization
            drawHandVisualization(landmarks);
            
            // Detect gesture (simplified for reliability)
            const gestureResult = detectSimpleGesture(landmarks);
            const newGesture = gestureResult.gesture;
            const confidence = gestureResult.confidence;
            
            // Update confidence display
            confidenceFill.style.width = (confidence * 100) + '%';
            gestureConfidence = confidence;
            
            // Only update if gesture changed and confidence is good
            if (newGesture !== currentGesture && confidence > 0.6) {
                currentGesture = newGesture;
                currentGestureElement.textContent = currentGesture;
                
                // Show feedback
                showGestureFeedback(currentGesture);
                
                // Update UI
                updateGestureUI();
                
                // Execute gesture action
                executeGestureAction(currentGesture, landmarks);
            }
            
            // Continuous control for open hand gesture
            if (currentGesture === 'Open Hand' && confidence > 0.7) {
                controlMovement(landmarks);
            }
        }
        
        // Simple, reliable gesture detection
        function detectSimpleGesture(landmarks) {
            // Get key points
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // Calculate finger extended status (simplified)
            const indexExtended = indexTip.y < landmarks[6].y; // Tip above PIP joint
            const middleExtended = middleTip.y < landmarks[10].y;
            const ringExtended = ringTip.y < landmarks[14].y;
            const pinkyExtended = pinkyTip.y < landmarks[18].y;
            
            // Thumb extended (different calculation)
            const thumbExtended = thumbTip.x > landmarks[3].x;
            
            // Count extended fingers
            let extendedCount = 0;
            if (indexExtended) extendedCount++;
            if (middleExtended) extendedCount++;
            if (ringExtended) extendedCount++;
            if (pinkyExtended) extendedCount++;
            
            // Gesture detection
            let gesture = 'Unknown';
            let confidence = 0;
            
            // Pointing: Only index finger extended
            if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                gesture = 'Pointing';
                confidence = 0.8;
            }
            // Open hand: All fingers extended
            else if (indexExtended && middleExtended && ringExtended && pinkyExtended) {
                gesture = 'Open Hand';
                confidence = 0.9;
            }
            // Peace sign: Index and middle extended, others not
            else if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                gesture = 'Peace';
                confidence = 0.85;
            }
            // Fist: No fingers extended
            else if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                gesture = 'Fist';
                confidence = 0.8;
            }
            
            return { gesture, confidence };
        }
        
        // Draw hand visualization
        function drawHandVisualization(landmarks) {
            handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
            
            // Draw connections
            handCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            handCtx.lineWidth = 2;
            
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8], // Index
                [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
            ];
            
            connections.forEach(connection => {
                const [start, end] = connection;
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                
                handCtx.beginPath();
                handCtx.moveTo(startPoint.x * handCanvas.width, startPoint.y * handCanvas.height);
                handCtx.lineTo(endPoint.x * handCanvas.width, endPoint.y * handCanvas.height);
                handCtx.stroke();
            });
            
            // Draw landmarks
            landmarks.forEach((landmark, i) => {
                const x = landmark.x * handCanvas.width;
                const y = landmark.y * handCanvas.height;
                
                // Color based on gesture
                let color = '#4cc9f0';
                if (currentGesture === 'Pointing' && i === 8) color = '#00ff88';
                if (currentGesture === 'Peace' && (i === 8 || i === 12)) color = '#00ff88';
                
                handCtx.fillStyle = color;
                handCtx.beginPath();
                handCtx.arc(x, y, 3, 0, Math.PI * 2);
                handCtx.fill();
            });
        }
        
        // Show gesture feedback
        function showGestureFeedback(gesture) {
            const emojiMap = {
                'Pointing': 'üëÜ',
                'Open Hand': '‚úã',
                'Peace': '‚úåÔ∏è',
                'Fist': '‚úä',
                'Unknown': '‚ùì'
            };
            
            gestureFeedback.textContent = emojiMap[gesture] || '‚ùì';
            gestureFeedback.classList.add('show');
            
            setTimeout(() => {
                gestureFeedback.classList.remove('show');
            }, 800);
        }
        
        // Update gesture UI
        function updateGestureUI() {
            // Reset all
            [gesturePointUI, gestureOpenUI, gesturePeaceUI].forEach(el => {
                el.classList.remove('active');
            });
            
            // Activate current
            switch(currentGesture) {
                case 'Pointing':
                    gesturePointUI.classList.add('active');
                    break;
                case 'Open Hand':
                    gestureOpenUI.classList.add('active');
                    break;
                case 'Peace':
                    gesturePeaceUI.classList.add('active');
                    break;
            }
        }
        
        // Execute gesture action
        function executeGestureAction(gesture, landmarks) {
            switch(gesture) {
                case 'Pointing':
                    selectObject(landmarks);
                    break;
                case 'Peace':
                    navigateSection(1);
                    break;
                case 'Fist':
                    navigateSection(-1);
                    break;
            }
        }
        
        // Control movement with open hand
        function controlMovement(landmarks) {
            const wrist = landmarks[0];
            
            // Convert hand position to camera movement
            const panX = (wrist.x - 0.5) * 10; // -5 to 5 range
            const panZ = (wrist.y - 0.5) * 10;
            
            // Smooth camera movement
            camera.position.x += (panX - camera.position.x) * 0.05;
            camera.position.z += (panZ + 15 - camera.position.z) * 0.05;
            
            // Look at center
            camera.lookAt(0, 0, 0);
        }
        
        // Select object by pointing
        function selectObject(landmarks) {
            const indexTip = landmarks[8];
            
            // Convert finger position to screen coordinates
            const x = (indexTip.x * 2) - 1;
            const y = -(indexTip.y * 2) + 1;
            
            // Raycasting to find intersected objects
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            const intersects = raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                const objectIndex = selectedObject.userData.index;
                
                // Update selection
                updateSelection(objectIndex);
            }
        }
        
        // Update selection
        function updateSelection(index) {
            // Reset all objects
            objects.forEach(obj => {
                obj.material.opacity = 0.5;
                obj.scale.set(1, 1, 1);
            });
            
            // Highlight selected object
            objects[index].material.opacity = 1;
            objects[index].scale.set(1.3, 1.3, 1.3);
            
            // Update current index
            currentObjectIndex = index;
            
            // Update UI
            updateSectionDisplay();
            
            // Move camera to focus on object
            const targetPosition = objects[index].position.clone();
            targetPosition.z += 8;
            targetPosition.y += 2;
            
            animateCameraTo(targetPosition);
        }
        
        // Navigate between sections
        function navigateSection(direction) {
            currentObjectIndex += direction;
            
            // Wrap around
            if (currentObjectIndex < 0) currentObjectIndex = objects.length - 1;
            if (currentObjectIndex >= objects.length) currentObjectIndex = 0;
            
            // Update selection
            updateSelection(currentObjectIndex);
        }
        
        // Update section display
        function updateSectionDisplay() {
            const section = portfolioSections[currentObjectIndex];
            
            sectionTitle.textContent = section.title;
            currentSectionElement.textContent = `${currentObjectIndex + 1} of ${objects.length}`;
            
            // Update description
            document.querySelector('#welcome-panel p:nth-of-type(2)').textContent = section.description;
        }
        
        // Animate camera to position
        function animateCameraTo(targetPosition) {
            const startPosition = camera.position.clone();
            const startTime = Date.now();
            const duration = 1000;
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function
                const easeProgress = easeOutCubic(progress);
                
                // Interpolate position
                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                
                // Look at the object
                const targetObject = objects[currentObjectIndex];
                camera.lookAt(targetObject.position.x, targetObject.position.y + 1, targetObject.position.z);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            animateCamera();
        }
        
        // Easing function
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Animate objects
            objects.forEach((obj, index) => {
                const time = Date.now() * 0.001;
                
                // Gentle floating
                obj.position.y = Math.sin(time + index) * 0.2;
                
                // Slow rotation
                obj.rotation.y += 0.005;
            });
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        // Initialize on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>