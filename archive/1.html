<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Particle System | Three.js + MediaPipe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #videoContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            height: 240px;
            border: 2px solid #00ffea;
            border-radius: 8px;
            overflow: hidden;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
        }

        #video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            display: block;
        }

        #canvasOutput {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffea;
            border-radius: 8px;
            padding: 15px;
            min-width: 200px;
            z-index: 2;
            backdrop-filter: blur(10px);
        }

        .stat-item {
            margin-bottom: 5px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
        }

        .stat-value {
            color: #ff00ff;
            font-weight: bold;
        }

        #gesture-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff00ff;
            border-radius: 20px;
            padding: 15px 30px;
            z-index: 2;
            text-align: center;
            min-width: 300px;
        }

        #gesture-name {
            font-size: 20px;
            color: #00ffea;
            margin-bottom: 5px;
        }

        #gesture-desc {
            font-size: 14px;
            opacity: 0.8;
        }

        #controls {
            position: absolute;
            left: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffea;
            border-radius: 12px;
            padding: 20px;
            width: 300px;
            z-index: 2;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-title {
            color: #00ffea;
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background: #1a1a2e;
            border: 1px solid #00ffea;
            color: #00ffea;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        button:hover {
            background: #00ffea;
            color: #000;
        }

        button.active {
            background: #00ffea;
            color: #000;
        }

        .slider-container {
            margin-bottom: 10px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #1a1a2e;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00ffea;
            border-radius: 50%;
            cursor: pointer;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00ffea;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 255, 234, 0.2);
            border-top: 5px solid #00ffea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #toggleCamera {
            margin-top: 10px;
        }

        #handSkeleton {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 3;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="renderCanvas"></canvas>
        
        <div id="videoContainer">
            <video id="video" playsinline></video>
            <canvas id="canvasOutput"></canvas>
        </div>
        
        <div id="stats">
            <div class="stat-item">
                <span>Particles:</span>
                <span id="particleCount" class="stat-value">5000</span>
            </div>
            <div class="stat-item">
                <span>FPS:</span>
                <span id="fps" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span>Hands:</span>
                <span id="handCount" class="stat-value">0</span>
            </div>
            <div class="stat-item">
                <span>Mode:</span>
                <span id="modeDisplay" class="stat-value">Starfield</span>
            </div>
            <div class="stat-item">
                <span>Gesture:</span>
                <span id="gestureDisplay" class="stat-value">None</span>
            </div>
        </div>
        
        <div id="gesture-info">
            <div id="gesture-name">Waiting for hand...</div>
            <div id="gesture-desc">Show your hand to the camera to start</div>
        </div>
        
        <div id="controls">
            <div class="control-group">
                <div class="control-title">
                    <span>Hand Tracking</span>
                    <button id="toggleCamera">Hide Camera</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <span>Particle System</span>
                    <button id="resetParticles">Reset</button>
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Count:</span>
                        <span id="countValue">5000</span>
                    </div>
                    <input type="range" id="particleSlider" min="1000" max="10000" step="1000" value="5000">
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Size:</span>
                        <span id="sizeValue">0.1</span>
                    </div>
                    <input type="range" id="sizeSlider" min="0.05" max="0.5" step="0.05" value="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <span>Visual Mode</span>
                </div>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="starfield">Starfield</button>
                    <button class="mode-btn" data-mode="energy">Energy</button>
                    <button class="mode-btn" data-mode="fireworks">Fireworks</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <span>Effects</span>
                </div>
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Force:</span>
                        <span id="forceValue">0.5</span>
                    </div>
                    <input type="range" id="forceSlider" min="0.1" max="2" step="0.1" value="0.5">
                </div>
            </div>
        </div>
        
        <div id="loading">
            <div class="spinner"></div>
            <h3>Loading Hand Tracking...</h3>
            <p>Please allow camera access when prompted</p>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe for hand tracking -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- Simplex Noise for organic motion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // Main Application Class
        class GestureParticleSystem {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.particleCount = 5000;
                this.particleMode = 'starfield';
                this.currentGesture = 'none';
                this.hands = [];
                this.handPosition = new THREE.Vector3(0, 0, 0);
                this.forceStrength = 0.5;
                this.particleSize = 0.1;
                this.simplex = new SimplexNoise();
                
                this.initThreeJS();
                this.initParticles();
                this.initMediaPipe();
                this.initUI();
                this.animate();
            }
            
            initThreeJS() {
                // Create scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000011);
                this.scene.fog = new THREE.Fog(0x000022, 10, 50);
                
                // Create camera
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 20);
                
                // Create renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('renderCanvas'),
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
                this.scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0x00ffea, 0.5);
                pointLight.position.set(5, 5, 5);
                this.scene.add(pointLight);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Add grid helper
                const gridHelper = new THREE.GridHelper(50, 50, 0x00ffea, 0x005555);
                gridHelper.position.y = -10;
                this.scene.add(gridHelper);
            }
            
            initParticles() {
                // Create particle geometry
                const geometry = new THREE.BufferGeometry();
                
                // Create arrays for particle attributes
                const positions = new Float32Array(this.particleCount * 3);
                const velocities = new Float32Array(this.particleCount * 3);
                const colors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                // Initialize particles in a sphere
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Random position in sphere
                    const radius = 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i3 + 2] = radius * Math.cos(phi);
                    
                    // Random velocity
                    velocities[i3] = (Math.random() - 0.5) * 0.01;
                    velocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                    
                    // Set color based on mode
                    this.setParticleColor(colors, i, this.particleMode);
                    
                    // Random size
                    sizes[i] = Math.random() * this.particleSize + 0.05;
                }
                
                // Store for later updates
                this.particlePositions = positions;
                this.particleVelocities = velocities;
                this.particleColors = colors;
                this.particleSizes = sizes;
                
                // Set geometry attributes
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                // Create particle material
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true,
                    blending: THREE.AdditiveBlending
                });
                
                // Create particle system
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                
                // Store geometry reference
                this.particleGeometry = geometry;
            }
            
            setParticleColor(colors, index, mode) {
                const i3 = index * 3;
                let r, g, b;
                
                switch(mode) {
                    case 'starfield':
                        // White/blue stars
                        const intensity = Math.random();
                        r = intensity * 0.2 + 0.8;
                        g = intensity * 0.3 + 0.7;
                        b = 1.0;
                        break;
                        
                    case 'energy':
                        // Colorful energy particles
                        const hue = Math.random();
                        if (hue < 0.33) {
                            r = 1.0;
                            g = Math.sin(hue * Math.PI) * 0.8;
                            b = 0.2;
                        } else if (hue < 0.66) {
                            r = Math.cos((hue - 0.33) * Math.PI) * 0.8;
                            g = 1.0;
                            b = 0.2;
                        } else {
                            r = 0.2;
                            g = Math.sin((hue - 0.66) * Math.PI) * 0.8;
                            b = 1.0;
                        }
                        break;
                        
                    case 'fireworks':
                        // Warm firework colors
                        r = Math.random() * 0.5 + 0.5;
                        g = Math.random() * 0.3 + 0.2;
                        b = Math.random() * 0.2;
                        break;
                        
                    default:
                        r = 1.0; g = 1.0; b = 1.0;
                }
                
                colors[i3] = r;
                colors[i3 + 1] = g;
                colors[i3 + 2] = b;
            }
            
            async initMediaPipe() {
                try {
                    // Get video element
                    const videoElement = document.getElementById('video');
                    const canvasElement = document.getElementById('canvasOutput');
                    const canvasCtx = canvasElement.getContext('2d');
                    
                    // Set canvas size
                    canvasElement.width = 320;
                    canvasElement.height = 240;
                    
                    // Create MediaPipe Hands
                    const hands = new Hands({
                        locateFile: (file) => {
                            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                        }
                    });
                    
                    // Configure hands
                    hands.setOptions({
                        maxNumHands: 2,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    // Handle results
                    hands.onResults((results) => {
                        // Clear canvas
                        canvasCtx.save();
                        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                        
                        // Store hand data
                        this.hands = results.multiHandLandmarks || [];
                        
                        if (this.hands.length > 0) {
                            // Get first hand
                            const hand = this.hands[0];
                            
                            // Draw hand landmarks
                            this.drawHandLandmarks(canvasCtx, hand);
                            
                            // Classify gesture
                            this.classifyGesture(hand);
                            
                            // Calculate hand center in 3D space
                            this.calculateHandPosition(hand);
                        } else {
                            this.currentGesture = 'none';
                            this.updateGestureDisplay();
                        }
                        
                        // Update hand count display
                        document.getElementById('handCount').textContent = this.hands.length;
                        
                        canvasCtx.restore();
                    });
                    
                    // Start camera
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({image: videoElement});
                        },
                        width: 320,
                        height: 240
                    });
                    
                    await camera.start();
                    
                    // Hide loading screen
                    document.getElementById('loading').style.display = 'none';
                    
                } catch (error) {
                    console.error('Error initializing MediaPipe:', error);
                    document.getElementById('loading').innerHTML = `
                        <h3>Camera Error</h3>
                        <p>Unable to access camera. Please allow camera permissions.</p>
                        <p>Using mouse controls instead.</p>
                    `;
                    this.setupMouseControls();
                }
            }
            
            drawHandLandmarks(ctx, landmarks) {
                // Draw connections
                const connections = [
                    [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                    [0, 5], [5, 6], [6, 7], [7, 8], // Index
                    [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                    [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                    [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                    [5, 9], [9, 13], [13, 17] // Palm
                ];
                
                // Set drawing style
                ctx.strokeStyle = '#00ffea';
                ctx.fillStyle = '#ff00ff';
                ctx.lineWidth = 2;
                
                // Draw connections
                ctx.beginPath();
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    ctx.moveTo(startPoint.x * 320, startPoint.y * 240);
                    ctx.lineTo(endPoint.x * 320, endPoint.y * 240);
                });
                ctx.stroke();
                
                // Draw landmarks
                landmarks.forEach(landmark => {
                    ctx.beginPath();
                    ctx.arc(landmark.x * 320, landmark.y * 240, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            classifyGesture(landmarks) {
                // Calculate finger distances and positions
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const palmBase = landmarks[0];
                
                // Calculate distances from palm base to finger tips
                const thumbDist = this.distance(thumbTip, palmBase);
                const indexDist = this.distance(indexTip, palmBase);
                const middleDist = this.distance(middleTip, palmBase);
                const ringDist = this.distance(ringTip, palmBase);
                const pinkyDist = this.distance(pinkyTip, palmBase);
                
                // Calculate distances between fingertips
                const thumbIndexDist = this.distance(thumbTip, indexTip);
                const indexMiddleDist = this.distance(indexTip, middleTip);
                
                // Determine which fingers are extended
                const avgDist = (indexDist + middleDist + ringDist + pinkyDist) / 4;
                const thumbExtended = thumbDist > avgDist * 0.8;
                const indexExtended = indexDist > avgDist * 1.2;
                const middleExtended = middleDist > avgDist * 1.2;
                const ringExtended = ringDist > avgDist * 1.2;
                const pinkyExtended = pinkyDist > avgDist * 1.2;
                
                // Classify gesture
                let gesture = 'none';
                
                if (indexExtended && middleExtended && !ringExtended && !pinkyExtended) {
                    gesture = 'peace';
                } else if (indexExtended && !middleExtended && !ringExtended && !pinkyExtended && thumbExtended) {
                    gesture = 'point';
                } else if (indexExtended && middleExtended && ringExtended && pinkyExtended && thumbExtended) {
                    gesture = 'open_palm';
                } else if (!indexExtended && !middleExtended && !ringExtended && !pinkyExtended && !thumbExtended) {
                    gesture = 'fist';
                } else if (thumbExtended && !indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                    gesture = 'thumbs_up';
                } else if (thumbIndexDist < 0.05) {
                    gesture = 'pinch';
                }
                
                // Update gesture
                if (gesture !== this.currentGesture) {
                    this.currentGesture = gesture;
                    this.updateGestureDisplay();
                    
                    // Visual feedback for gesture change
                    this.gestureFeedback();
                }
            }
            
            distance(p1, p2) {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const dz = p1.z - p2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
            
            calculateHandPosition(landmarks) {
                // Calculate center of hand
                let sumX = 0, sumY = 0, sumZ = 0;
                
                landmarks.forEach(landmark => {
                    sumX += landmark.x;
                    sumY += landmark.y;
                    sumZ += landmark.z;
                });
                
                const centerX = sumX / 21;
                const centerY = sumY / 21;
                const centerZ = sumZ / 21;
                
                // Convert normalized coordinates to 3D space
                // Map from [0,1] to [-15, 15] in X and Y, with Z based on hand size
                this.handPosition.x = (centerX - 0.5) * 30;
                this.handPosition.y = -(centerY - 0.5) * 30; // Invert Y
                this.handPosition.z = (0.5 - centerZ) * 20; // Use Z for depth
            }
            
            updateGestureDisplay() {
                const gestureNames = {
                    'peace': '‚úåÔ∏è Peace Sign',
                    'point': 'üëÜ Pointing',
                    'open_palm': 'üñêÔ∏è Open Hand',
                    'fist': '‚úä Fist',
                    'thumbs_up': 'üëç Thumbs Up',
                    'pinch': 'ü§è Pinch',
                    'none': 'Waiting...'
                };
                
                const gestureDescriptions = {
                    'peace': 'Creating particle streams',
                    'point': 'Directional control',
                    'open_palm': 'Attracting particles',
                    'fist': 'Repelling particles',
                    'thumbs_up': 'Changing colors',
                    'pinch': 'Manipulating clusters',
                    'none': 'Show your hand to the camera'
                };
                
                document.getElementById('gesture-name').textContent = gestureNames[this.currentGesture];
                document.getElementById('gesture-desc').textContent = gestureDescriptions[this.currentGesture];
                document.getElementById('gestureDisplay').textContent = this.currentGesture.replace('_', ' ');
            }
            
            gestureFeedback() {
                // Visual feedback when gesture changes
                if (this.currentGesture !== 'none') {
                    // Briefly increase particle size around hand
                    const positions = this.particleGeometry.attributes.position.array;
                    const sizes = this.particleGeometry.attributes.size.array;
                    
                    for (let i = 0; i < this.particleCount; i++) {
                        const i3 = i * 3;
                        const dx = positions[i3] - this.handPosition.x;
                        const dy = positions[i3 + 1] - this.handPosition.y;
                        const dz = positions[i3 + 2] - this.handPosition.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance < 5) {
                            sizes[i] = this.particleSize * 3;
                        }
                    }
                    
                    this.particleGeometry.attributes.size.needsUpdate = true;
                    
                    // Reset after 200ms
                    setTimeout(() => {
                        for (let i = 0; i < this.particleCount; i++) {
                            sizes[i] = this.particleSizes[i];
                        }
                        this.particleGeometry.attributes.size.needsUpdate = true;
                    }, 200);
                }
            }
            
            applyGestureEffects() {
                if (this.currentGesture === 'none' || this.hands.length === 0) return;
                
                const positions = this.particleGeometry.attributes.position.array;
                const velocities = this.particleVelocities;
                const colors = this.particleGeometry.attributes.color.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    
                    const dx = positions[i3] - this.handPosition.x;
                    const dy = positions[i3 + 1] - this.handPosition.y;
                    const dz = positions[i3 + 2] - this.handPosition.z;
                    
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < 10) {
                        let force = 0;
                        let colorEffect = false;
                        
                        switch(this.currentGesture) {
                            case 'open_palm':
                                // Attract particles to hand
                                force = -this.forceStrength * 0.001 / (distance + 0.1);
                                break;
                                
                            case 'fist':
                                // Repel particles from hand
                                force = this.forceStrength * 0.002 / (distance + 0.1);
                                break;
                                
                            case 'peace':
                                // Create swirling motion
                                const angle = Date.now() * 0.001;
                                const swirlX = Math.cos(angle + i * 0.01) * 0.0005;
                                const swirlY = Math.sin(angle + i * 0.01) * 0.0005;
                                positions[i3] += swirlX;
                                positions[i3 + 1] += swirlY;
                                break;
                                
                            case 'thumbs_up':
                                // Color shift effect
                                colors[i3] = Math.sin(Date.now() * 0.001 + i) * 0.5 + 0.5;
                                colors[i3 + 1] = Math.cos(Date.now() * 0.001 + i) * 0.5 + 0.5;
                                colors[i3 + 2] = Math.sin(Date.now() * 0.002 + i) * 0.5 + 0.5;
                                colorEffect = true;
                                break;
                                
                            case 'pinch':
                                // Pull particles toward center
                                if (distance < 3) {
                                    force = -this.forceStrength * 0.005;
                                    // Make pinched particles brighter
                                    colors[i3] = Math.min(colors[i3] * 1.5, 1.0);
                                    colors[i3 + 1] = Math.min(colors[i3 + 1] * 1.5, 1.0);
                                    colors[i3 + 2] = Math.min(colors[i3 + 2] * 1.5, 1.0);
                                }
                                break;
                        }
                        
                        if (force !== 0) {
                            velocities[i3] += dx * force;
                            velocities[i3 + 1] += dy * force;
                            velocities[i3 + 2] += dz * force;
                        }
                        
                        if (colorEffect) {
                            this.particleGeometry.attributes.color.needsUpdate = true;
                        }
                    }
                    
                    // Apply organic motion with simplex noise
                    const time = Date.now() * 0.001;
                    const noiseX = this.simplex.noise3D(
                        positions[i3] * 0.05,
                        positions[i3 + 1] * 0.05,
                        time
                    ) * 0.01;
                    const noiseY = this.simplex.noise3D(
                        positions[i3 + 1] * 0.05,
                        time,
                        positions[i3 + 2] * 0.05
                    ) * 0.01;
                    const noiseZ = this.simplex.noise3D(
                        time,
                        positions[i3] * 0.05,
                        positions[i3 + 2] * 0.05
                    ) * 0.01;
                    
                    velocities[i3] += noiseX;
                    velocities[i3 + 1] += noiseY;
                    velocities[i3 + 2] += noiseZ;
                    
                    // Apply velocity damping
                    velocities[i3] *= 0.98;
                    velocities[i3 + 1] *= 0.98;
                    velocities[i3 + 2] *= 0.98;
                    
                    // Update position
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];
                }
                
                this.particleGeometry.attributes.position.needsUpdate = true;
            }
            
            updateParticlePhysics() {
                const positions = this.particleGeometry.attributes.position.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    
                    // Boundary check - keep particles in sphere
                    const radius = 20;
                    const distance = Math.sqrt(
                        positions[i3] * positions[i3] +
                        positions[i3 + 1] * positions[i3 + 1] +
                        positions[i3 + 2] * positions[i3 + 2]
                    );
                    
                    if (distance > radius) {
                        // Push back toward center
                        const scale = radius / distance;
                        positions[i3] *= scale;
                        positions[i3 + 1] *= scale;
                        positions[i3 + 2] *= scale;
                        
                        // Reverse velocity component
                        this.particleVelocities[i3] *= -0.5;
                        this.particleVelocities[i3 + 1] *= -0.5;
                        this.particleVelocities[i3 + 2] *= -0.5;
                    }
                }
            }
            
            setupMouseControls() {
                document.addEventListener('mousemove', (e) => {
                    // Convert mouse to 3D coordinates
                    const x = (e.clientX / window.innerWidth) * 2 - 1;
                    const y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    // Update hand position
                    this.handPosition.x = x * 15;
                    this.handPosition.y = y * 15;
                    
                    // Update gesture based on mouse buttons
                    if (e.buttons & 1) { // Left click
                        this.currentGesture = 'fist';
                    } else if (e.buttons & 2) { // Right click
                        this.currentGesture = 'peace';
                    } else {
                        this.currentGesture = 'open_palm';
                    }
                    
                    this.updateGestureDisplay();
                });
                
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) this.currentGesture = 'fist';
                    if (e.button === 2) this.currentGesture = 'peace';
                    this.updateGestureDisplay();
                });
                
                document.addEventListener('mouseup', () => {
                    this.currentGesture = 'open_palm';
                    this.updateGestureDisplay();
                });
                
                // Prevent context menu on right click
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                
                document.getElementById('gesture-name').textContent = 'Mouse Controls Active';
                document.getElementById('gesture-desc').textContent = 'Move mouse to control particles, click to change gestures';
            }
            
            initUI() {
                // Particle count slider
                const particleSlider = document.getElementById('particleSlider');
                const countValue = document.getElementById('countValue');
                
                particleSlider.addEventListener('input', (e) => {
                    this.particleCount = parseInt(e.target.value);
                    countValue.textContent = this.particleCount;
                    document.getElementById('particleCount').textContent = this.particleCount;
                    this.resizeParticleSystem(this.particleCount);
                });
                
                // Size slider
                const sizeSlider = document.getElementById('sizeSlider');
                const sizeValue = document.getElementById('sizeValue');
                
                sizeSlider.addEventListener('input', (e) => {
                    this.particleSize = parseFloat(e.target.value);
                    sizeValue.textContent = this.particleSize.toFixed(2);
                    
                    // Update all particle sizes
                    const sizes = this.particleGeometry.attributes.size.array;
                    for (let i = 0; i < this.particleCount; i++) {
                        this.particleSizes[i] = Math.random() * this.particleSize + 0.05;
                        sizes[i] = this.particleSizes[i];
                    }
                    this.particleGeometry.attributes.size.needsUpdate = true;
                });
                
                // Force slider
                const forceSlider = document.getElementById('forceSlider');
                const forceValue = document.getElementById('forceValue');
                
                forceSlider.addEventListener('input', (e) => {
                    this.forceStrength = parseFloat(e.target.value);
                    forceValue.textContent = this.forceStrength.toFixed(1);
                });
                
                // Mode buttons
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        this.particleMode = btn.dataset.mode;
                        document.getElementById('modeDisplay').textContent = 
                            this.particleMode.charAt(0).toUpperCase() + this.particleMode.slice(1);
                        
                        this.changeParticleMode(this.particleMode);
                    });
                });
                
                // Toggle camera
                document.getElementById('toggleCamera').addEventListener('click', () => {
                    const videoContainer = document.getElementById('videoContainer');
                    const btn = document.getElementById('toggleCamera');
                    
                    if (videoContainer.style.opacity === '0' || videoContainer.style.opacity === '') {
                        videoContainer.style.opacity = '1';
                        btn.textContent = 'Hide Camera';
                    } else {
                        videoContainer.style.opacity = '0';
                        btn.textContent = 'Show Camera';
                    }
                });
                
                // Reset particles
                document.getElementById('resetParticles').addEventListener('click', () => {
                    this.resetParticles();
                });
            }
            
            resizeParticleSystem(newCount) {
                // Create new arrays
                const newPositions = new Float32Array(newCount * 3);
                const newVelocities = new Float32Array(newCount * 3);
                const newColors = new Float32Array(newCount * 3);
                const newSizes = new Float32Array(newCount);
                
                // Copy existing particles
                const copyCount = Math.min(newCount, this.particleCount);
                
                for (let i = 0; i < copyCount; i++) {
                    const i3 = i * 3;
                    newPositions[i3] = this.particlePositions[i3];
                    newPositions[i3 + 1] = this.particlePositions[i3 + 1];
                    newPositions[i3 + 2] = this.particlePositions[i3 + 2];
                    
                    newVelocities[i3] = this.particleVelocities[i3];
                    newVelocities[i3 + 1] = this.particleVelocities[i3 + 1];
                    newVelocities[i3 + 2] = this.particleVelocities[i3 + 2];
                    
                    newColors[i3] = this.particleColors[i3];
                    newColors[i3 + 1] = this.particleColors[i3 + 1];
                    newColors[i3 + 2] = this.particleColors[i3 + 2];
                    
                    newSizes[i] = this.particleSizes[i];
                }
                
                // Add new particles if needed
                for (let i = copyCount; i < newCount; i++) {
                    const i3 = i * 3;
                    const radius = 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    newPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    newPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    newPositions[i3 + 2] = radius * Math.cos(phi);
                    
                    newVelocities[i3] = (Math.random() - 0.5) * 0.01;
                    newVelocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                    newVelocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                    
                    this.setParticleColor(newColors, i, this.particleMode);
                    newSizes[i] = Math.random() * this.particleSize + 0.05;
                }
                
                // Update arrays
                this.particlePositions = newPositions;
                this.particleVelocities = newVelocities;
                this.particleColors = newColors;
                this.particleSizes = newSizes;
                this.particleCount = newCount;
                
                // Update geometry
                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
                this.particleGeometry.setAttribute('size', new THREE.BufferAttribute(newSizes, 1));
            }
            
            changeParticleMode(mode) {
                for (let i = 0; i < this.particleCount; i++) {
                    this.setParticleColor(this.particleColors, i, mode);
                }
                
                // Update colors in geometry
                this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(this.particleColors, 3));
                this.particleGeometry.attributes.color.needsUpdate = true;
                
                // Change scene background based on mode
                switch(mode) {
                    case 'starfield':
                        this.scene.background = new THREE.Color(0x000011);
                        this.scene.fog = new THREE.Fog(0x000022, 10, 50);
                        break;
                    case 'energy':
                        this.scene.background = new THREE.Color(0x110022);
                        this.scene.fog = new THREE.Fog(0x220044, 10, 40);
                        break;
                    case 'fireworks':
                        this.scene.background = new THREE.Color(0x000000);
                        this.scene.fog = new THREE.Fog(0x000000, 15, 35);
                        break;
                }
            }
            
            resetParticles() {
                for (let i = 0; i < this.particleCount; i++) {
                    const i3 = i * 3;
                    const radius = 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    this.particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                    this.particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    this.particlePositions[i3 + 2] = radius * Math.cos(phi);
                    
                    this.particleVelocities[i3] = (Math.random() - 0.5) * 0.01;
                    this.particleVelocities[i3 + 1] = (Math.random() - 0.5) * 0.01;
                    this.particleVelocities[i3 + 2] = (Math.random() - 0.5) * 0.01;
                }
                
                this.particleGeometry.attributes.position.needsUpdate = true;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Apply gesture effects
                this.applyGestureEffects();
                
                // Update particle physics
                this.updateParticlePhysics();
                
                // Rotate camera slowly for better view
                const time = Date.now() * 0.001;
                this.camera.position.x = Math.sin(time * 0.1) * 25;
                this.camera.position.z = Math.cos(time * 0.1) * 25;
                this.camera.lookAt(0, 0, 0);
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                // Update FPS counter
                this.updateFPS();
            }
            
            updateFPS() {
                if (!this.lastTime) {
                    this.lastTime = performance.now();
                    this.frames = 0;
                }
                
                this.frames++;
                const currentTime = performance.now();
                
                if (currentTime >= this.lastTime + 1000) {
                    const fps = Math.round((this.frames * 1000) / (currentTime - this.lastTime));
                    document.getElementById('fps').textContent = fps;
                    this.lastTime = currentTime;
                    this.frames = 0;
                }
            }
        }
        
        // Initialize the application
        window.addEventListener('load', () => {
            new GestureParticleSystem();
        });
    </script>
</body>
</html>